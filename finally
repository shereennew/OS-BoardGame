#include <pthread.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <signal.h>
#include <sys/wait.h>

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>

#include <string>
#include <queue>
using namespace std;

/* =======================
   CONFIG
   ======================= */
#define SERVER_PORT 5555
#define BACKLOG 10
static const int MAX_PLAYERS = 4;
static const char* SHM_NAME = "/guess_game_shm_demo";

/* =======================
   SHARED STATE
   ======================= */
struct SharedState {
    pthread_mutex_t shared_mutex;
    int shared_int[4];
    /*
        [0] current_player
        [1] connected_mask
        [2] secret_number
        [3] game_status (0 running, 1 finished)
    */
};

static int listen_fd = -1;
static SharedState* g_state = nullptr;

/* =======================
   LOGGER
   ======================= */
static pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t  log_cv    = PTHREAD_COND_INITIALIZER;
static queue<string> log_queue;
static bool logger_running = true;

static string nowString() {
    char buf[64];
    time_t t = time(nullptr);
    tm tm{};
    localtime_r(&t, &tm);
    snprintf(buf, sizeof(buf),
             "%04d-%02d-%02d %02d:%02d:%02d",
             tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
             tm.tm_hour, tm.tm_min, tm.tm_sec);
    return string(buf);
}

static void logPush(const string& msg) {
    pthread_mutex_lock(&log_mutex);
    log_queue.push(nowString() + " " + msg);
    pthread_cond_signal(&log_cv);
    pthread_mutex_unlock(&log_mutex);
}

static void* loggerThread(void*) {
    FILE* fp = fopen("game.log", "a");
    if (!fp) return nullptr;

    logPush("[LOG] Logger started.");

    while (true) {
        pthread_mutex_lock(&log_mutex);
        while (log_queue.empty() && logger_running)
            pthread_cond_wait(&log_cv, &log_mutex);

        if (!logger_running && log_queue.empty()) {
            pthread_mutex_unlock(&log_mutex);
            break;
        }

        string msg = log_queue.front();
        log_queue.pop();
        pthread_mutex_unlock(&log_mutex);

        fprintf(fp, "%s\n", msg.c_str());
        fflush(fp);
    }

    fprintf(fp, "%s\n",
            (nowString() + " [LOG] Logger stopped.").c_str());
    fclose(fp);
    return nullptr;
}

/* =======================
   ROUND ROBIN SCHEDULER
   ======================= */
struct SchedulerArgs {
    SharedState* st;
    int quantum_ms;
};

static int findNextConnected(int current, int mask) {
    for (int i = 1; i <= MAX_PLAYERS; i++) {
        int next = (current + i) % MAX_PLAYERS;
        if (mask & (1 << next)) return next;
    }
    return current;
}

static void* roundRobinThread(void* arg) {
    SchedulerArgs* a = (SchedulerArgs*)arg;
    SharedState* st = a->st;

    logPush("[SCHED] Scheduler started.");

    while (true) {
        usleep(a->quantum_ms * 1000);

        pthread_mutex_lock(&st->shared_mutex);
        if (st->shared_int[3] != 0) {
            pthread_mutex_unlock(&st->shared_mutex);
            break;
        }

        int cur = st->shared_int[0];
        int mask = st->shared_int[1];

        if (!(mask & (1 << cur))) {
            int fixed = findNextConnected(cur, mask);
            st->shared_int[0] = fixed;
            pthread_mutex_unlock(&st->shared_mutex);
            logPush("[SCHED] Skip disconnected -> " + to_string(fixed));
            continue;
        }

        int next = findNextConnected(cur, mask);
        st->shared_int[0] = next;
        pthread_mutex_unlock(&st->shared_mutex);

        if (next != cur)
            logPush("[SCHED] Turn: " + to_string(cur) + " -> " + to_string(next));
    }

    logPush("[SCHED] Scheduler stopped.");
    return nullptr;
}

/* =======================
   SHARED MEMORY
   ======================= */
static void initProcessSharedMutex(pthread_mutex_t* mtx) {
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(mtx, &attr);
    pthread_mutexattr_destroy(&attr);
}

static SharedState* createSharedMemory() {
    shm_unlink(SHM_NAME);
    int fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (fd < 0) return nullptr;

    ftruncate(fd, sizeof(SharedState));

    void* mem = mmap(nullptr, sizeof(SharedState),
                     PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    close(fd);

    return (SharedState*)mem;
}

/* =======================
   CLIENT PROCESS
   ======================= */
static void client_process(int client_fd, int player_id) {
    close(listen_fd);

    char buf[128];
    snprintf(buf, sizeof(buf),
             "WELCOME PLAYER %d\n", player_id);
    write(client_fd, buf, strlen(buf));

    while (true) {
        pthread_mutex_lock(&g_state->shared_mutex);

        if (g_state->shared_int[3] != 0) {
            pthread_mutex_unlock(&g_state->shared_mutex);
            break;
        }

        int cur = g_state->shared_int[0];
        pthread_mutex_unlock(&g_state->shared_mutex);

        if (cur != player_id) {
            usleep(200 * 1000);
            continue;
        }

        write(client_fd, "YOUR TURN: GUESS 1-100\n", 23);

        char in[32];
        int n = read(client_fd, in, sizeof(in) - 1);
        if (n <= 0) break;
        in[n] = '\0';

        int guess = atoi(in);

        pthread_mutex_lock(&g_state->shared_mutex);
        int secret = g_state->shared_int[2];

        if (guess == secret) {
            write(client_fd, "WIN\n", 4);
            g_state->shared_int[3] = 1;
            pthread_mutex_unlock(&g_state->shared_mutex);
            logPush("[GAME] Player " + to_string(player_id) + " WON.");
            break;
        } else if (guess < secret) {
            write(client_fd, "HIGHER\n", 7);
        } else {
            write(client_fd, "LOWER\n", 6);
        }

        pthread_mutex_unlock(&g_state->shared_mutex);
    }

    pthread_mutex_lock(&g_state->shared_mutex);
    g_state->shared_int[1] &= ~(1 << player_id);
    pthread_mutex_unlock(&g_state->shared_mutex);

    close(client_fd);
    exit(0);
}

/* =======================
   SOCKET / SIGNAL
   ======================= */
static void sigchld_handler(int) {
    while (waitpid(-1, nullptr, WNOHANG) > 0);
}

static void setup_sigchld() {
    struct sigaction sa{};
    sa.sa_handler = sigchld_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sigaction(SIGCHLD, &sa, nullptr);
}

static int setup_server_socket() {
    int fd = socket(AF_INET, SOCK_STREAM, 0);
    int opt = 1;
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(SERVER_PORT);

    bind(fd, (sockaddr*)&addr, sizeof(addr));
    listen(fd, BACKLOG);
    return fd;
}

/* =======================
   MAIN
   ======================= */
int main() {
    setup_sigchld();

    SharedState* st = createSharedMemory();
    if (!st) return 1;
    g_state = st;

    memset(st, 0, sizeof(SharedState));
    initProcessSharedMutex(&st->shared_mutex);

    pthread_mutex_lock(&st->shared_mutex);
    st->shared_int[0] = 0;
    st->shared_int[1] = 0;
    st->shared_int[3] = 0;
    srand(time(nullptr));
    st->shared_int[2] = (rand() % 100) + 1;
    pthread_mutex_unlock(&st->shared_mutex);

    logPush("[GAME] Secret generated.");

    pthread_t log_tid;
    pthread_create(&log_tid, nullptr, loggerThread, nullptr);

    SchedulerArgs args{st, 800};
    pthread_t sched_tid;
    pthread_create(&sched_tid, nullptr, roundRobinThread, &args);

    listen_fd = setup_server_socket();
    logPush("[SERVER] Listening on port 5555.");

    int next_player = 0;

    while (1) {
        sockaddr_in cli{};
        socklen_t len = sizeof(cli);
        int cfd = accept(listen_fd, (sockaddr*)&cli, &len);
        if (cfd < 0) continue;

        pthread_mutex_lock(&st->shared_mutex);
        if (next_player >= MAX_PLAYERS) {
            pthread_mutex_unlock(&st->shared_mutex);
            close(cfd);
            continue;
        }

        int pid = next_player++;
        st->shared_int[1] |= (1 << pid);
        pthread_mutex_unlock(&st->shared_mutex);

        logPush("[SERVER] Player " + to_string(pid) + " connected.");

        pid_t f = fork();
        if (f == 0) {
            client_process(cfd, pid);
        }

        close(cfd);
    }

    return 0;
}
